// Generated by CoffeeScript 1.7.1

/*

    Subscription mixin for React.

    Expects a 'manifest' of subscriptions in `statics.subscriptions`
    with `subscribe`, `unsubscribe`, and `default` methods.

    Example:
    
    React.createClass
        mixins: [SubscriptionMixin]
        statics: ->
            subscriptions: (props) ->
                users:
                    subscribe: -> 
                         * initiate subscription
                    unsubscribe: ->
                         * clean up
                    shouldUpdateSubscription: (oldProps, newProps) ->
                         * Return true if subscription should update
                         * when props change
                    default: -> 
                         * default value for the prop
 */

(function() {
  var getRootComponent, setSubscriptionPropsCallback;

  getRootComponent = require("./utils").getRootComponent;

  setSubscriptionPropsCallback = function(owner, path, defaultData) {
    return function(data) {
      var props;
      props = {};
      props[path] = data || defaultData;
      return owner.setProps(props);
    };
  };

  module.exports = {
    subscribe: function(props) {
      var owner, path, subscription, _base, _ref, _results;
      owner = getRootComponent(this);
      this.__subscriptions = {};
      _ref = typeof (_base = this.type).subscriptions === "function" ? _base.subscriptions(props) : void 0;
      _results = [];
      for (path in _ref) {
        subscription = _ref[path];
        _results.push((function(_this) {
          return function(path, subscription) {
            subscription.subscribe(setSubscriptionPropsCallback(owner, path, subscription["default"]));
            return _this.__subscriptions[path] = subscription;
          };
        })(this)(path, subscription));
      }
      return _results;
    },
    unsubscribe: function() {
      var path, subscription, _ref, _results;
      _ref = this.__subscriptions;
      _results = [];
      for (path in _ref) {
        subscription = _ref[path];
        subscription.unsubscribe();
        _results.push(delete this.__subscriptions[path]);
      }
      return _results;
    },
    componentDidMount: function() {
      return this.subscribe(this.props);
    },
    componentWillUnmount: function() {
      return this.unsubscribe();
    },
    componentWillReceiveProps: function(newProps) {
      var owner, path, pathsToUpdate, subscription, _ref;
      owner = getRootComponent(this);
      pathsToUpdate = [];
      _ref = this.__subscriptions;
      for (path in _ref) {
        subscription = _ref[path];
        if (typeof subscription.shouldUpdateSubscription === "function" ? subscription.shouldUpdateSubscription(this.props, newProps) : void 0) {
          pathsToUpdate.push(path);
        }
      }
      if (pathsToUpdate.length > 0) {
        return setTimeout((function(_this) {
          return function() {
            var newSubscriptions, _i, _len, _results;
            newSubscriptions = _this.type.subscriptions(newProps);
            _results = [];
            for (_i = 0, _len = pathsToUpdate.length; _i < _len; _i++) {
              path = pathsToUpdate[_i];
              _this.__subscriptions[path].unsubscribe();
              _this.__subscriptions[path] = newSubscriptions[path];
              _results.push(_this.__subscriptions[path].subscribe(setSubscriptionPropsCallback(owner, path)));
            }
            return _results;
          };
        })(this), 50);
      }
    },
    getDefaultProps: function() {
      var path, props, subscription, _base, _ref;
      props = {};
      _ref = typeof (_base = this.type).subscriptions === "function" ? _base.subscriptions(this.props) : void 0;
      for (path in _ref) {
        subscription = _ref[path];
        props[path] = props[path] || subscription["default"];
      }
      return props;
    }
  };

}).call(this);
