// Generated by CoffeeScript 1.7.1

/*

  **Problem:** Firebase expects a single JSON file to specify security rules for an app. But a large app will have many rules, and I'd rather separate these rules into different files.

  **Solution:** This module iterates over a directory of JSON/JS/CoffeeScript files, creates a nested hash of all the rules (maintaining the structure of the files/directories), and outputs all rules into a single JSON file.
 */

(function() {
  var argv, fs, path, readPath, renameParent, requireDirectory, traverse, writePath, _;

  requireDirectory = require('require-directory');

  argv = require("optimist").argv;

  _ = require("underscore");

  fs = require("fs");

  traverse = require("traverse");

  path = require("path");

  readPath = argv._[0];

  writePath = argv._[1];

  renameParent = function(traversal, context, object, from, to) {
    var basePath, newPath;
    if (context.key === from) {
      basePath = context.parent.path;
      newPath = basePath.concat([to]);
      traversal.set(newPath, object);
      return context.remove();
    }
  };

  module.exports = function(readPath, writePath) {
    var key, rules, rulesFromFiles, traversal, _i, _len, _ref;
    console.log("Begin to merge Firebase rules:");
    if (!readPath) {
      console.log("...No path provided. Quitting.");
      return false;
    } else {
      console.log("...Reading from: " + readPath);
    }
    rulesFromFiles = requireDirectory(module, readPath, /_[^\/]*$/);
    traversal = traverse(rulesFromFiles);
    traversal.forEach(function(object) {
      renameParent(traversal, this, object, "validate", ".validate");
      renameParent(traversal, this, object, "read", ".read");
      return renameParent(traversal, this, object, "write", ".write");
    });
    traversal.forEach(function(object) {
      var basePath, key, newPath, value, _ref;
      if ((_ref = this.key) === 'index' || _ref === 'root') {
        basePath = this.parent.path;
        for (key in object) {
          value = object[key];
          newPath = basePath.concat([key]);
          traversal.set(newPath, value);
        }
        return this.remove();
      }
    });
    rules = JSON.stringify(rulesFromFiles, null, 4);
    fs.writeFileSync(writePath, rules);
    console.log("...Compiled rules: " + writePath);
    readPath = path.resolve(readPath);
    _ref = _(require.cache).keys();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (key.match(RegExp("^" + readPath))) {
        delete require.cache[key];
      }
    }
    return rules;
  };

}).call(this);
