// Generated by CoffeeScript 1.7.1

/*

    Router for React.

    Use @Mixin on the client and @create on the server.

    On the client, @Mixin goes into the root component and sets
    route matches into props.matchedRoute.

    Expects a path list:

        routes =  [
            { path: "/",                 handler: Home },
            { path: "/writing",          handler: Writing },
            { path: "/writing/:slug",    handler: WritingView },
            { path: "*",                 handler: NotFound }
        ]

    When matchRoute(path) is called, a matchedRoute object
    is set into this.props:

        matchedRoute:
            path: "/writing/my-post"
            params:
                slug: "my-post"
            handler: WritingView
 */

(function() {
  var RouterMixin, closest, urlPattern, _;

  _ = require("underscore");

  urlPattern = require('url-pattern');

  closest = function(el, tag) {
    tag = tag.toUpperCase();
    if (el.nodeName === tag) {
      return el;
    }
    while (el = el.parentNode) {
      if (el.nodeName === tag) {
        return el;
      }
    }
    return null;
  };

  RouterMixin = this.Mixin = {
    componentWillMount: function() {
      return this.props.matchedRoute = this.matchRoute(this.props.path || window.location.pathname);
    },
    handleClick: function(e) {
      var link, _ref;
      if (link = closest(e.target, 'A')) {
        if (((_ref = link.getAttribute("href")) != null ? _ref[0] : void 0) === "/") {
          e.preventDefault();
          e.stopPropagation();
          return this.navigate(link.pathname);
        }
      }
    },
    handlePopstate: function() {
      var path;
      path = window.location.pathname;
      if (this.props.matchedRoute.path !== path) {
        return this.setProps({
          matchedRoute: this.matchRoute(path)
        });
      }
    },
    componentDidMount: function() {
      return window.addEventListener('popstate', this.handlePopstate);
    },
    matchRoute: function(path) {
      var matchedRoute, params, pattern, route, _i, _len, _ref;
      if (path[path.length - 1] !== "/") {
        path += "/";
      }
      _ref = this.routes || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        route = _ref[_i];
        if (route.path[route.path.length - 1] !== "/") {
          route.path += "/";
        }
        pattern = urlPattern.newPattern(route.path);
        params = pattern.match(path);
        if (params) {
          matchedRoute = {
            path: path,
            params: params,
            handler: route.handler
          };
          return matchedRoute;
        }
      }
    },
    navigate: function(path, callback) {
      window.history.pushState(null, null, path);
      return this.setProps({
        matchedRoute: this.matchRoute(path)
      }, callback);
    }
  };

  this.create = function(routes) {
    var Router;
    Router = _.clone(RouterMixin);
    _.extend(Router, {
      routes: routes,
      add: function(route) {
        return this.routes.push(route);
      }
    });
    return Router;
  };

}).call(this);
